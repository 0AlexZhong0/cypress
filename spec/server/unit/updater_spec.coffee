require("../spec_helper")

delete global.fs

os          = require("os")
tar         = require("tar-fs")
cwd         = require("#{root}lib/cwd")
home        = require("home-or-tmp")
Updater     = require("#{root}lib/updater")
Fixtures    = require("#{root}/spec/server/helpers/fixtures")

describe "lib/updater", ->
  context "interface", ->
    it "returns an updater instance", ->
      u = Updater({})
      expect(u).to.be.instanceof Updater

  context "#getPackage", ->
    beforeEach ->
      @sandbox.stub(fs, "readJsonSync").returns({foo: "bar"})

      @updater = Updater({})

    it "inserts manifestUrl to package.json", ->
      expect(@updater.getPackage()).to.deep.eq {
        foo: "bar"
        manifestUrl: "https://download.cypress.io/desktop.json"
      }

  context "#getClient", ->
    it "sets .client to new Updater", ->
      u = Updater({})
      u.getClient()
      expect(u.client).to.have.property("checkNewVersion")

    it "returns .client if exists", ->
      u = Updater({})
      client  = u.getClient()
      client2 = u.getClient()
      expect(client).to.eq(client2)

  context "#normalizeArgs", ->
    beforeEach ->
      @env = process.env.CYPRESS_ENV

      process.env.CYPRESS_ENV = "production"

      @updater = Updater({})
      @updater.getClient()

    afterEach ->
      process.env.CYPRESS_ENV = @env

    it "resets appPath + execPath on OSX", ->
      @sandbox.stub(os, "platform").returns("darwin")

      expect(@updater.normalizeArgs({
        appPath:  "/Users/bmann/Dev"
        execPath: "/Users/bmann/Dev"
      })).to.deep.eq({
        appPath: "/Applications/Cypress.app"
        execPath: "/Applications/Cypress.app"
      })

    it "does not reset appPath + execPath on OSX", ->
      @sandbox.stub(os, "platform").returns("darwin")

      expect(@updater.normalizeArgs({
        appPath:  "/foo/Cypress.app"
        execPath: "/foo/Cypress.app"
      })).to.deep.eq({
        appPath: "/foo/Cypress.app"
        execPath: "/foo/Cypress.app"
      })

    it "resets appPath + execPath on linux", ->
      @sandbox.stub(os, "platform").returns("linux")
      @sandbox.stub(@updater, "getHome").returns("/home/vagrant")

      expect(@updater.normalizeArgs({
        appPath:  "/Users/bmann/Dev"
        execPath: "/Users/bmann/Dev"
      })).to.deep.eq({
        appPath:  "/home/vagrant/.cypress/Cypress"
        execPath: "/home/vagrant/.cypress/Cypress/Cypress"
      })

    it "does not reset appPath + execPath on linux", ->
      @sandbox.stub(os, "platform").returns("linux")

      expect(@updater.normalizeArgs({
        appPath:  "/foo/Cypress"
        execPath: "/foo/Cypress/Cypress"
      })).to.deep.eq({
        appPath: "/foo/Cypress"
        execPath: "/foo/Cypress/Cypress"
      })

  context "#getHome", ->
    beforeEach ->
      @updater = Updater({})

    it "returns home-or-tmp", ->
      expect(@updater.getHome()).to.eq(home)

  context "#getArgs", ->
    beforeEach ->
      @updater = Updater({})
      @updater.getClient()
      @sandbox.stub(@updater.client, "getAppExec").returns("bar")

    it "compacts null values", ->
      @sandbox.stub(@updater.client, "getAppPath").returns("foo")
      expect(@updater.getArgs()).to.deep.eq ["--app-path=foo", "--exec-path=bar", "--updating"]

    it "changes cwd to be the original + then restores", ->
      tmp = os.tmpDir()

      ## manually change process.cwd
      process.chdir(tmp)

      localCwd = cwd()

      fn = ->
        process.cwd() + "/baz"

      @sandbox.stub(@updater.client, "getAppPath", fn)

      args = @updater.getArgs()

      expect(args).to.deep.eq(["--app-path=#{localCwd + "/baz"}", "--exec-path=bar", "--updating"])

      expect(args[0]).not.to.include(tmp)

      expect(process.cwd()).to.include(tmp)
      expect(process.cwd()).not.to.include(localCwd)

  context ".run", ->
    beforeEach ->
      @updater = Updater({})
      @updater.getClient()
      @checkNewVersion = @sandbox.stub(@updater.client, "checkNewVersion")
      @sandbox.stub(process, "exit")

    it "invokes onRun", ->
      spy = @sandbox.spy()
      Updater.run({onStart: spy})
      expect(spy).to.be.called

    describe "client#checkNewVersion", ->
      beforeEach ->
        @download = @sandbox.stub(Updater.prototype, "download")

      it "is called once", ->
        @updater.run()
        expect(@checkNewVersion).to.be.calledOnce

      it "calls #download if new version exists", ->
        @checkNewVersion.yields(null, true, {})
        @updater.run()
        expect(@download).to.be.calledOnce

      it "passes manifest to #download when new version exists", ->
        @checkNewVersion.yields(null, true, {foo: "bar"})
        @updater.run()
        expect(@download).to.be.calledWith({foo: "bar"})

      it "does not call #download if there isnt a new version", ->
        @checkNewVersion.yields(null, false, {foo: "bar"})
        @updater.run()
        expect(@download).not.to.be.called

      it "invokes onNone when there isnt a new version", ->
        spy = @sandbox.spy()
        @checkNewVersion.yields(null, false)
        @updater.callbacks.onNone = spy
        @updater.run()
        expect(spy).to.be.called

      it "does not call #download if there is an error", ->
        @checkNewVersion.yields((new Error), true, {foo: "bar"})
        @updater.run()
        expect(@download).not.to.be.called

      it "invokes onError callbacks", ->
        err = new Error("checking onError")
        spy = @sandbox.spy()
        @checkNewVersion.yields(err)
        @updater.callbacks.onError = spy
        @updater.run()
        expect(spy).to.be.calledWith(err)

    describe "#download", ->
      beforeEach ->
        @sandbox.stub(@updater.client, "download")
        @sandbox.stub(@updater, "unpack")
        @clock = @sandbox.useFakeTimers()

      it "invokes onDownload", ->
        spy = @sandbox.spy()
        @updater.callbacks.onDownload = spy
        @updater.download({})
        @clock.tick(1000)
        expect(spy).to.be.called

      it "calls unpack with destinationPath and manifest", ->
        @updater.client.download.yields(null, "/Users/bmann/app")
        @updater.download({})
        @clock.tick(1000)
        expect(@updater.unpack).to.be.calledOnce.and.to.be.calledWith("/Users/bmann/app", {})

      it "does not call unpack on error", ->
        @updater.client.download.yields((new Error), "/Users/bmann/app")
        @updater.download({})
        @clock.tick(1000)
        expect(@updater.unpack).not.to.be.called

      it "invokes onError callbacks", ->
        err = new Error("checking onError")
        spy = @sandbox.spy()
        @updater.callbacks.onError = spy
        @updater.client.download.yields(err)
        @updater.download({})
        @clock.tick(1000)
        expect(spy).to.be.calledWith(err)

    describe "#unpack", ->
      beforeEach ->
        @sandbox.stub(@updater.client, "unpack")
        @sandbox.stub(@updater, "runInstaller")

      it "invokes onApply", ->
        spy = @sandbox.spy()
        @updater.callbacks.onApply = spy
        @updater.unpack("/some/path", {})
        expect(spy).to.be.called

      it "calls runInstaller with newAppPath", ->
        @updater.client.unpack.yields(null, "/Users/bmann/app")
        @updater.unpack("/some/path", {})
        expect(@updater.runInstaller).to.be.calledOnce.and.to.be.calledWith("/Users/bmann/app")

      it "does not call runInstaller on error", ->
        @updater.client.unpack.yields((new Error), "/Users/bmann/app")
        @updater.unpack("/some/path", {})
        expect(@updater.runInstaller).not.to.be.called

      it "invokes onError callbacks", ->
        err = new Error("checking onError")
        spy = @sandbox.spy()
        @updater.callbacks.onError = spy
        @updater.client.unpack.yields(err)
        @updater.unpack("/some/path", {})
        expect(spy).to.be.calledWith(err)

    describe "#runInstaller", ->
      beforeEach ->
        @sandbox.stub(@updater.client, "runInstaller")
        # @sandbox.stub(@updater,        "copyCyDataTo").resolves()

      it "calls process.exit", ->
        @updater.runInstaller("/Users/bmann/newApp")
        expect(process.exit).to.be.calledOnce

      it "calls runInstaller on the client", ->
        c = @updater.client
        @updater.runInstaller("/Users/bmann/newApp")

        expect(@updater.client.runInstaller).to.be.calledWith("/Users/bmann/newApp", ["--app-path=#{c.getAppPath()}", "--exec-path=#{c.getAppExec()}", "--updating"], {})

      ## we no longer pass up additional App argv
      ## other than from debug i'm not sure why we
      ## would have ever wanted to do this. in fact
      ## its caused a bug in parseArgs and its duplicated
      ## every existing argument
      it "does not pass along additional App argv", ->
        c = @updater.client
        @updater.runInstaller("/Users/bmann/newApp")
        expect(@updater.client.runInstaller).to.be.calledWith("/Users/bmann/newApp", ["--app-path=#{c.getAppPath()}", "--exec-path=#{c.getAppExec()}", "--updating"], {})

    describe "#copyCyDataTo", ->
      beforeEach ->
        fs.outputJsonAsync(".cy/cache", {foo: "bar"}).then ->
          fs.outputFileAsync(".cy/foo/bar.txt", "foo!").then ->
            fs.outputJsonAsync("new/app/path/Contents/Resources/app/package.json", {})

      afterEach ->
        fs.removeAsync("new").then ->
          fs.removeAsync(".cy/foo")

    describe "#copyTmpToAppPath", ->
      beforeEach ->
        @onStub = @sandbox.stub()
        @onStub.withArgs("error").returnsThis()

        @onPipe = @sandbox.stub().returnsThis()

        @sandbox.stub(tar, "pack").returns({
          on: @onStub
          pipe: @onPipe
        })

        @sandbox.stub(tar, "extract").returns("extractFoo")

      it "calls tar.pack", ->
        @onStub.withArgs("finish").yieldsAsync()

        @updater.copyTmpToAppPath("a", "b").then ->
          expect(tar.pack).to.be.calledWith("a", {
            fs: require("original-fs")
          })

      it "calls tar.extract", ->
        @onStub.withArgs("finish").yieldsAsync()

        @updater.copyTmpToAppPath("a", "b").then ->
          expect(tar.extract).to.be.calledWith("b", {
            fs: require("original-fs")
          })

      it "pipes return value of tar.extract", ->
        @onStub.withArgs("finish").yieldsAsync()

        @updater.copyTmpToAppPath("a", "b").then =>
          expect(@onPipe).to.be.calledWith("extractFoo")

      it "throws on error", ->
        err = new Error("foo")
        @onStub.withArgs("error").yieldsAsync(err)

        @updater.copyTmpToAppPath("a", "b")
        .then ->
          throw new Error("should have failed but did not")
        .catch (e) ->
          expect(e).to.eq(err)

    describe "#trash", ->
      beforeEach ->
        fs.outputFileAsync("random/dirs/and/file.txt", "foobarbaz!")

      it "moves directory to trash", (done) ->
        @updater.trash("random").then ->
          fs.statAsync("random")
            .then -> done("random should not exist!")
            .catch -> done()

    describe "#install", ->
      beforeEach ->
        @argsObj = {
          appPath:  "/Users/bmann/app_path"
          execPath: "/Users/bmann/app_exec_path"
        }

        @sandbox.stub(@updater.client, "getAppPath").returns("foo")
        @sandbox.stub(@updater, "copyTmpToAppPath").resolves()

        @run     = @sandbox.stub(@updater.client, "run")
        @trash   = @sandbox.stub(@updater, "trash").resolves()

      it "trashes current appPath", ->
        @updater.install(@argsObj).then =>
          expect(@trash).to.be.calledWith("/Users/bmann/app_path")

      it "calls #copyTmpToAppPath with tmp + appPath", ->
        @updater.install(@argsObj).then =>
          expect(@updater.copyTmpToAppPath).to.be.calledWith "foo", @argsObj.appPath

      it "calls process.exit", ->
        @updater.install(@argsObj).then =>
          expect(process.exit).to.be.calledOnce

      it "calls client.run with execPath + args", ->
        @updater.install(@argsObj).then =>
          expect(@run).to.be.calledWith(@argsObj.execPath, [])

      context "args", ->
        beforeEach ->
          @argsObj = {
            updating: true
            appPath: "app"
            execPath: "exec"
            "getKey": true
          }

        it "uses args object", ->
          @updater.install(@argsObj).then =>
            expect(@run).to.be.calledWith("exec", ["--getKey=true"])

  context "integration", ->
    before ->
      ## 10 min timeout
      @timeout(10 * 60 * 1000)

      ## ensure we have the cypress.zip fixture
      Fixtures.ensureNwZip()

    beforeEach ->
      ## force a lower package.json version
      @sandbox.stub(fs, "readJsonSync").returns({version: "0.0.1"})

      ## force a manifest.json response here to be a slightly higher version
      nock("http://download.cypress.io")
        .get("/desktop.json")
        .reply 200, {
          name: "cypress"
          version: "0.0.2"
          packages: {
            mac: {
              url: "http://cdn.cypress.io/desktop/0.0.2/cypress.zip"
            }
            win: {
              url: "http://cdn.cypress.io/desktop/0.0.2/cypress.zip"
            }
            linux: {
              url: "http://cdn.cypress.io/desktop/0.0.2/cypress.zip"
            }
          }
        }
        .get("/dist.cypress.io/0.0.2/cypress.zip")
        .reply 200, ->
          fs.createReadStream Fixtures.path("nw/cypress.zip")

    # it "runs", ->
    #   @updater = Updater({quit: @sandbox.spy()})
    #   @updater.run()

  context "#check", ->
    beforeEach ->
      @updater = Updater({quit: @sandbox.spy()})
      @updater.getClient()
      @sandbox.stub(@updater.client, "checkNewVersion")

    it "calls checkNewVersion", ->
      @updater.check()
      expect(@updater.client.checkNewVersion).to.be.called

    it "calls optsions.newVersionExists when there is a no version", ->
      @updater.client.checkNewVersion.yields(null, true, {})

      options = {onNewVersion: @sandbox.spy()}
      @updater.check(options)

      expect(options.onNewVersion).to.be.calledWith({})

    it "calls options.newVersionExists when there is a no version", ->
      @updater.client.checkNewVersion.yields(null, false)

      options = {onNoNewVersion: @sandbox.spy()}
      @updater.check(options)

      expect(options.onNoNewVersion).to.be.called
