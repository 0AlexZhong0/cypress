import { Visitor, namedTypes, builders } from 'ast-types'

const b = builders

/**
 * Create an AST Visitor that applies JS transformations required for Cypress.
 *
 * @see https://github.com/benjamn/ast-types#ast-traversal
 *  for details on how the Visitor is implemented
 *
 * @see https://astexplorer.net/#/gist/7f1e645c74df845b0e1f814454e9bbdf/f443b701b53bf17fbbf40e9285cb8b65a4066240
 *  to explore ASTs generated by recast
 */
const getJsRules = (): Visitor<{}> => {
  // use `globalThis` instead of `window`, `self`... to lower chances of scope conflict
  // users can technically override even this, but it would be very rude
  // "[globalThis] provides a way for polyfills/shims, build tools, and portable code to have a reliable non-eval means to access the global..."
  // @see https://github.com/tc39/proposal-global/blob/master/NAMING.md
  const globalIdentifier = b.identifier('globalThis')

  function match (accessedObject, prop: string, maybeVal?: any) {
    const args = [
      // window
      globalIdentifier,
      // accessedObject
      accessedObject,
      // 'prop'
      b.stringLiteral(prop),
    ]

    if (maybeVal) {
      // maybeVal is a Node
      args.push(maybeVal)
    }

    return b.callExpression(
      b.memberExpression(
        b.memberExpression(
          b.memberExpression(
            globalIdentifier,
            b.identifier('top'),
          ),
          b.identifier('Cypress'),
        ),
        b.identifier('resolveWindowReference'),
      ),
      args,
    )
  }

  // (PROP === window['PROP'] ? MATCH : PROP)
  function closureDetectionTern (prop: string) {
    return b.parenthesizedExpression(
      b.conditionalExpression(
        b.binaryExpression(
          '===',
          b.identifier(prop),
          b.memberExpression(
            globalIdentifier,
            b.stringLiteral(prop),
            true,
          ),
        ),
        match(globalIdentifier, prop),
        b.identifier(prop),
      ),
    )
  }

  function getReplaceablePropOfMemberExpression (node: namedTypes.MemberExpression) {
    // something.(top|parent)
    if (node.property.type === 'Identifier' && ['parent', 'top', 'location', 'frames'].includes(node.property.name)) {
      return node.property.name
    }

    // something['(top|parent)']
    if (node.property.type === 'Literal' && ['parent', 'top', 'location', 'frames'].includes(String(node.property.value))) {
      return String(node.property.value)
    }

    return
  }

  return {
    visitMemberExpression (path) {
      // is it a property access?
      const { node } = path

      const prop = getReplaceablePropOfMemberExpression(node)

      if (!prop) {
        return this.traverse(path)
      }

      path.replace(match(path.get('object').node, prop))

      return false
    },
    visitIdentifier (path) {
      const { node } = path

      if (path.parentPath) {
        const parentNode = path.parentPath.node

        // some Identifiers do not refer to a scoped variable, depending on how they're used
        if (
          // like `var top = 'foo'`
          (parentNode.type === 'VariableDeclarator' && parentNode.id === node)
          // like top = 'foo'
          || (parentNode.type === 'AssignmentExpression' && parentNode.left === node)
          || (
            [
              'LabeledStatement', // like `top: foo();`
              'Property', // like `{ top: 'foo' }`
              'FunctionDeclaration', // like `function top()`
              'RestElement', // like (...top)
              'ArrowFunctionExpression', // like `(top, ...parent) => { }`
              'ArrowExpression', // MDN Parser docs mention this being used for () => {}
              'FunctionExpression', // like `(function top())`,
            ].includes(parentNode.type)
          )
        ) {
          return false
        }
      }

      if (['parent', 'top', 'location', 'frames'].includes(node.name)) {
        path.replace(closureDetectionTern(node.name))

        return false
      }

      return this.traverse(path)
    },
    visitAssignmentExpression (path) {
      const { node } = path

      const finish = () => {
        this.traverse(path)
      }

      if (node.left.type !== 'MemberExpression') {
        return finish()
      }

      const propBeingSet = getReplaceablePropOfMemberExpression(node.left)

      if (!propBeingSet) {
        return finish()
      }

      if (node.operator !== '=') {
        // in the case of +=, -=, |=, etc., assume they're not doing something like
        // `window.top += 4` since that would be invalid anyways, just continue down the RHS
        this.traverse(path.get('right'))

        return false
      }

      const objBeingSetOn = (node.left as namedTypes.MemberExpression).object

      path.replace(match(objBeingSetOn, propBeingSet, node.right))

      return false
    },
  }
}

export const jsRules = getJsRules()
